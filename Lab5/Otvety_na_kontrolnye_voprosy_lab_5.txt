1. Что такое поток? В чём состоит ключевое отличие потока от процесса?
Поток (thread) – это абстракция уровня операционной системы, содержащая
отдельный контекст (стек) выполнения, позволяющая выполнять несколько задач
одновременно или переключаться между ними.
различия
В отличии от потоков, процессы не разделяют свои собственные ресурсы с прочими процессами.

2. Что такое процесс? В чём состоят ключевые отличия между процессами и потоками?
Процесс - это абстракция совокупности взаимосвязанных системных ресурсов на основе отдельного и независимого 
виртуального адресного пространства
Процесс - это экземпляр программы, это совокупность потоков. Процесс обладает своим адресным пространством и контекстом выполнения.

3. Что такое многопроцессорность? В чём состоят ключевые отличия между многопроцессорностью и многопоточностью?
Многопроцессорность - это использование пары или большего количества физических 
процессоров в одной компьютерной системе
Многопоточность осуществляется внутри одного процесса
А многопросцессорность на разыных ядрах процессора

4. Что предлагают параметры, предлагаемые модулем threading из Python?
Thread, Condition, Semaphore, Barrier, Event, Timer, Lock, RLock Objects

5. Какие варианты API предоставляются модулем multiprocessing?
Ярким примером этого является объект Pool, который предлагает удобное средство 
распараллеливания выполнения функции по нескольким входным значениям, распределяя 
входные данные по процессам (параллелизм данных).
Process, Pipe, Queue
Функция Pipe() возвращает пару объектов connection, соединенных каналом, который по умолчанию является дуплексным (двусторонним).
Класс Queue является близким клоном queue.Queue.
Большинство API аналогичны Threading

6. Что такое процесс демона?
Потоки-демоны — это потоки, которые выполняют задачи в фоновом режиме. 
Чтобы создать поток-демон, в конструкторе Thread нужно указать аргумент daemon=True:
Программа не ждет завершения демона-потока перед выходом.

7. Что представляет собой GIL?
Global Interpreter Lock (GIL)
GIL был представлен, чтобы сделать работу с памятью CPython проще и
обеспечить наилучшую интеграцию с C (например, с расширениями). GIL – это механизм
блокировки, когда интерпретатор Python запускает в работу только один поток за раз. 

8. Принцип работы GIL.
Потоки удерживают GIL, пока выполняются. Однако они
освобождают его при блокировании для операций ввода-вывода. Каждый раз, когда поток
вынужден ждать, другие, готовые к выполнению, потоки используют свой шанс
запуститься.

9. Для каких задач стоит использовать модуль threading?
Для операций ввода/вывода в основном выбираются потоки, загрузка ресурсов из интернета или 
чтение файлов и папок на вашем компьютере.

10. Для каких задач стоит использовать модуль multiprocessing?
Для разбиения тяжёлых вычислений на более мелкие части.

11.Когда не стоит использовать ни threading, ни multiprocessing?
Когда нет тяжёлых вычислений и нужно выполнить какие-то простые команды, где параллелизм никчему.

12.Что стоит за основной идеей синхронизации потоков при помощи блокировки?
Блокировка позволяет синхронизировать разные потоки. Чтобы поток, который выполнился раньше
не нарушил логику программы.

13.Что составляет процесс реализации синхронизации потоков с применением блокировки в Python?
Помещаем потоки в очередь, запускаем программу. Другими словами, если два разных потока вызовут
.get то пока первый поток не выйдет из блока, второй будет его ждать – и только потом
продолжит выполнение

14.В чём основная идея структуры данных очереди?
Очередь в Python – это линейный тип структуры данных, используемый для последовательного хранения данных. 
Ее концепция основана на FIFO (“First in First Out”)

15.Что является основным приложением очередей для совместного программирования?
Цитата из документации: Это особенно полезно при многопоточном программировании, 
когда необходимо безопасно обмениваться информацией между несколькими потоками

16.Что составляет центральное отличие между обычными очередями и очередями с приоритетами?
Обычная очередь подчиняется принципу FIFO «первый вошел — первый вышел». В очередях с приоритетом
элементы удаляются в соответствии с их приоритетом. То есть, элемент с самым 
высоким приоритетом удаляется из очереди в первую очередь.